import scala.quoted.*
import scala.reflect.*
import TreesTest as T
import scala.annotation.tailrec

def isEmpty[T](list: List[T]) : Boolean = list == Nil || list == List[T]()
object Macros {
        
    inline def inverse[A, B](inline expr: A => B): Unit = //would like B => A
        ${firstLevel('expr)}

    inline def show[A,B](inline expr: A => B): Unit =
        ${printExpr('expr)}
    
    def printExpr[A,B](expr: Expr[A=>B])(using Quotes) = 
        '{  println(${CodePrinter.showExpr(expr)})
            println("======== Onto 2")
            println(${CodePrinter.showExpr2(expr)})
            println("======== Onto 3")
            println(${CodePrinter.showExpr3(expr)})}

    def firstLevel[A : Type , B : Type](expr: Expr[A => B])(using Quotes) = { // Todo change this : Expr[B=>A] 
        import quotes.reflect.*
        import reflect._

        val apply = "apply"
        val unapply = "unapply"

        def extractFunction(tree: Tree): Tree = {
            tree match {
                case Inlined(_,_, Block(list, term)) => 
                    if (list.size == 1)
                        list.head match {
                            // Only DefDef expected here
                            case DefDef(name, params, typeTree, body) => 
                                body match {
                                    case Some(Apply(function, x)) => 
                                        handleFunctionIdentifier(function.asInstanceOf[Ident])
                                    case None => throw new Error("No function body detected in autogenerated lambda")
                                    case _ => throw new Error("Incorrect function body detected")
                                }
                        }
                    else
                        throw new Error("Only the function must be passed")
                case Inlined(_,_, x :Ident) => handleFunctionIdentifier(x)
                case _ => 
                    throw new Error("Unknown format encountered in extractFunction")
            }

            
        }


        // Trivial function but useful to have as it prevents having to 
        // modify code in several spots in extract function
        def handleFunctionIdentifier(function : Ident): Tree ={
            function.symbol.tree 
        }

        def secondLevel(tree : Tree): DefDef = {
            tree match {
                case DefDef(functionName, params, typeTree, body) =>
                    // Here is the other print for the body
                    println(s"Original body is $body")
                    if(params.size != 1)
                        throw new Error("Function should only have one parameter")
                    val inputDefinition = params.head.params.head
                    val (inputName, inputType) = inputDefinition match {
                        case ValDef(name, tp, None) => (name, tp)
                        case _ => throw new Error("Function parameter was not inexpected format")
                    }

                    val newSymbol = Symbol.newMethod(Symbol.spliceOwner, s"$$$functionName-inverse", 
                        inputType.tpe)

                    def createMatch(body : Option[Term]): Match = {
                        body match {
                            case Some(Block( statements, Match(scrutinee, cases))) =>
                                if (!isEmpty(statements))
                                    throw new Error("Function does not respect format. Only functions containing one match are allowed")

                                //Check of format
                                if(scrutinee.symbol != inputDefinition.symbol)
                                    throw new Error("Only function argument is accepted as scrutinee for match")
                                
                                handleMatch(Match(scrutinee, cases), tree.symbol, newSymbol)
                            case Some(Match(scrutinee, cases)) =>

                                //Check of format
                                scrutinee match {
                                    case Ident(s) => 
                                        if( s != inputName)
                                            throw new Error("Only input is accepted as scrutinee for match")
                                    case _ => throw new Error("Only input is accepted as scrutinee for match")
                                }

                                handleMatch(Match(scrutinee, cases), tree.symbol, newSymbol)
                            case None =>  throw new Error("No function body detected")
                            case _ => throw new Error("Function does not respect format. Only functions containing one match are allowed")
                        }
                    }
                    /*
                    /*
                    This was another was to create the function that I attempted, 
                    I think it would be more correct than using copy, 
                    but I'm unsure of how to handle the parameters
                    */
                    val newBody = (x:List[List[Tree]]) => Some(createMatch(body,x))
                    
                    DefDef(newSymbol,
                            newBody)//.changeOwner(newSymbol) //Not sure about this
                    */
                    DefDef.copy(tree)
                        (s"$$$functionName-inverse", 
                            List(TermParamClause(List(ValDef.copy(tree)(inputName, typeTree, None)))), 
                            inputType, 
                            Some(createMatch(body)))
                case _ => throw new Error("A defined function was not found")
            }
        }

        def handleMatch(matche: Match, oldFunctionSymbol : Symbol, newFunctionSymbol : Symbol) : Match = {
            def handleCases(caseDef : CaseDef, scrutinee: Term) : CaseDef = {
                caseDef match {
                    case CaseDef(_, Some(_), _) => throw new Error("Case with guard are not yet supprorted") //todo
                    case CaseDef(pattern, None, rhs) => 
                        // Pattern becomes Rhs and vice versa
                        val (newPat, translations) = handleRhs(rhs, oldFunctionSymbol, newFunctionSymbol)
                        val newRhs = handlePattern(pattern, newFunctionSymbol, translations)
                        CaseDef(newPat, None, newRhs)
                }
            }
            matche.scrutinee match {
                // Check that scutinee is an identifier
                case Ident(s) => 
                    val res = Match(matche.scrutinee, matche.cases.map(handleCases(_, matche.scrutinee)))
                    // This is a check that the match produced is correct 
                    // (and it is correct otherwise it would throw)
                    res.asExpr.asInstanceOf[B]
                    // This is the result obtained
                    println(s"Final match is $res")
                    res
                case _ => throw new Error("Only simple identifier is accepted as scrutinee for match")
            }
        }

        def handlePattern(pattern: Tree, newFunctionSymbol : Symbol, translations: List[(Symbol, Term)]): Term = 
            def useTranslation(sym:Symbol): Option[Term] =
                val solutions = translations.distinct.filter(_._1 == sym)
                if solutions.isEmpty then None else Some(solutions.head._2)
            
            pattern match {
                case Ident(s) => 
                    if s == "_" then
                        System.err.println("Function contains wildcard as pattern, bijection may fail with MatchError. Removal of this case is suggested")
                        '{throw new Error("Impossible to biject, wildcard cannot be inverted")}.asTerm
                    else
                        useTranslation(pattern.symbol).getOrElse(pattern.asInstanceOf[Ident])
                case Some(e) => handlePattern(e.asInstanceOf[Tree], newFunctionSymbol, translations)
                case Block(statements, e) => 
                    if !isEmpty(statements) then 
                        throw new Error("Pattern is a non-empty block")
                    else
                        handlePattern(e, newFunctionSymbol, translations)
                case Typed(term, typeTree) =>
                    val res = handlePattern(term, newFunctionSymbol, translations)
                    //Typed(res, typeTree)
                    res
                                    
                case Unapply(fun, implicits, pattern) => 
                    if !isEmpty(implicits) then
                        throw new Error(s"handlePattern could not handle unapply which non-empty implicits: ${implicits}")

                    // gives list of parameters, and the corresponding terms to give to the apply
                    def unbindStrings(t : Tree):  List[Term]= t match {
                        case Bind(string, tree) => 
                            tree match {
                                case Ident(name) if name == "_" =>
                                        //TODO check project, maybe bug comes from here. Maybe also look up translation7
                                        val translation = translations.filter(_._1.name == string)
                                        if !translation.isEmpty then
                                            List(translation.head._2)
                                        else
                                            List(Ident(TermRef(tree.asInstanceOf[Ident].tpe, string)))
                                case _ : Term =>
                                    List(useTranslation(tree.symbol).getOrElse({println("=== No symbol found"); Ident(TermRef(tree.asInstanceOf[Term].tpe, string))}))
                                case _ => throw new Error(s"unbindString bind with non term tree ${tree}")
                            }
                        case _ => 
                            println(s"unbindString non-bind with ${t}")
                            val res = handlePattern(t, newFunctionSymbol, translations)
                            //List(handlePattern(t, newFunctionSymbol, translations))
                            println(s"unbindString non-bind gives ${res}")
                            throw new Error(s"unbindString non-bind with ${t}")
                    }
                    val newFun : Term = fun match {
                        case Select(term, string) => 
                            if string != unapply then 
                                throw new Error(s"handlePattern could not handle unapply with non-apply function selected")
                            val symbols = term.symbol.memberMethod(apply)
                            if isEmpty(symbols) then 
                                throw new Error(s"handlePattern could not find apply method on pattern")
                            Select(term, symbols.head)
                    }
                    //Problem with the terms
                    val terms = pattern.map(unbindStrings(_)).flatten
                    val res = Apply(newFun, terms)
                    res
                
                case _ =>
                    println("Pattern: " + pattern.show(using Printer.TreeStructure) )
                    throw new Error(s"handlePattern could not handle ${pattern}")
            }

        def handleRhs(term: Term, oldFunctionSymbol: Symbol, newFunctionSymbol : Symbol): (Tree, List[(Symbol, Term)]) ={
            term match{
                case Ident(s) => 
                    (term, List((term.symbol, term)))
                case Block(statements, e) => 
                    if !isEmpty(statements) then 
                        throw new Error("handleRhs Rhs is a non-empty block")
                    else
                        handleRhs(e, oldFunctionSymbol, newFunctionSymbol)
                case Apply(function, arguments) =>
                    
                    def createBinds(term : Term, function : Term) : (Bind, (Symbol, Term)) = term match{
                        case Ident(name) => 
                            val newSymbol = Symbol.newBind(term.symbol, name, Flags.EmptyFlags, function.tpe)
                            
                            (Bind(newSymbol, Ident.copy(term)("_")), (term.symbol, term))// Ident(TermRef(term.tpe,"_"))
                        case Apply(function, arguments) => 
                            if function.symbol == oldFunctionSymbol && arguments.size == 1 then 
                                val (bind, (symbol, _)) = createBinds(arguments.head, function)
                                //Ident(TermRef(newFunctionSymbol.tree.asInstanceOf[Term].tpe, newFunctionSymbol.name))
                                val translation = (symbol, Apply(Ident.copy(bind)(newFunctionSymbol.name), arguments))
                                (bind, translation)
                            else
                                throw new Error(s"createBinds in handleRhs could not handle Apply with ${function} and arg ${arguments}")

                        case _ => 
                            throw new Error(s"createBinds in handleRhs could not handle ${term} with symbol ${term.symbol}")
                    }
                    
                    val (classe: Term, newFun : Term) = function match {
                        case Select(term, string) => 
                            if string != apply then 
                                throw new Error(s"handleRhs could not handle apply with non-unapply function selected")
                            val symbols = term.symbol.memberMethod(unapply)
                            if isEmpty(symbols) then 
                                throw new Error(s"handleRhs could not find apply method on term")
                            (term,Select(term, symbols.head))
                    }
                    // Don't directly call create bind
                    val (binds, translations):(List[Bind], List[(Symbol, Term)]) = arguments.map(createBinds(_, classe)).unzip
                    val res = Unapply.copy(term)(newFun, Nil, binds)//(function,Nil, generate binds)
                    (res, translations)
                case _ => throw new Error(s"handleRhs could not handle $term")
            }
        }
        val tree : Term = expr.asTerm
        val innerTree = extractFunction(tree)
        val fun = secondLevel(innerTree)

        //TermRef(fun.returnTpt.tpe, fun.name) //TermRef(TypeRepr.memberType(fun.symbol), fun.name)

        val funBlock = Block(List(fun), Closure(Ident.copy(tree)(fun.name), Some(fun.returnTpt.tpe) ))

        // Try to uncomment this to see errors
        //funBlock.asExpr.asInstanceOf[Expr[B=>A]]
        
        Expr(3)    
    }


 
}

